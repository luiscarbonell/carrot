<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Liquid Carrot - neat.js - Documentation</title>
    <link rel="shortcut icon" href="/liquid-carrot-favicon.png" />
    
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="styles/bulma.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/ionicons/2.0.1/css/ionicons.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger">
  <div class="fixed-action-btn">
    <div class="button-floating">
      <!--
      <label for="nav-trigger" class="navicon-button x">
        <div class="navicon"></div>
      </label>
      -->
        <i class="ion-ios-book" aria-hidden="true"></i>
    </div>
  </div>
</label>
<label for="nav-trigger" class="overlay"></label>

<div class="navbar is-fixed-top" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="#" style="padding:0">
      <img src="img/carrot-logo.png" height="28">
    </a>

    <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbarBasicExample" class="navbar-menu">
    <div class="navbar-start">
      <a class="navbar-item" href="/">Home</a>
      <a class="navbar-item" href="/carrot">Docs</a>
      <a class="navbar-item" href="https://github.com/liquidcarrot/carrot" target="_blank"><i class="ion-social-github" aria-hidden="true"></i></a>

      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link">
          More
        </a>

        <div class="navbar-dropdown">
          <a class="navbar-item" href="mailto:people@liquidcarrot.io?subject=Contact%20From%20Docs">
            Contact
          </a>
          <hr class="navbar-divider">
          <a class="navbar-item" href="https://github.com/liquidcarrot/carrot/issues/new">
            Report an issue
          </a>
        </div>
      </div>
    </div>

    <div class="navbar-end">
      <div class="navbar-item">
        <input type="text" id="nav-search" placeholder="Search" autofocus>
      </div>
    </div>
  </div>
</div>

<nav >
    <h3>Classes</h3><ul><li><a href="Connection.html">Connection</a><ul class='methods'><li data-type='method'><a href="Connection.html#.innovationID">innovationID</a></li><li data-type='method'><a href="Connection.html#.toJSON">toJSON</a></li></ul></li><li><a href="Group.html">Group</a><ul class='methods'><li data-type='method'><a href="Group.html#activate">activate</a></li><li data-type='method'><a href="Group.html#clear">clear</a></li><li data-type='method'><a href="Group.html#connect">connect</a></li><li data-type='method'><a href="Group.html#disconnect">disconnect</a></li><li data-type='method'><a href="Group.html#gate">gate</a></li><li data-type='method'><a href="Group.html#propagate">propagate</a></li><li data-type='method'><a href="Group.html#set">set</a></li></ul></li><li><a href="Layer.html">Layer</a><ul class='methods'><li data-type='method'><a href="Layer.html#.Dense">Dense</a></li><li data-type='method'><a href="Layer.html#.GRU">GRU</a></li><li data-type='method'><a href="Layer.html#.LSTM">LSTM</a></li><li data-type='method'><a href="Layer.html#.Memory">Memory</a></li><li data-type='method'><a href="Layer.html#activate">activate</a></li><li data-type='method'><a href="Layer.html#clear">clear</a></li><li data-type='method'><a href="Layer.html#connect">connect</a></li><li data-type='method'><a href="Layer.html#disconnect">disconnect</a></li><li data-type='method'><a href="Layer.html#gate">gate</a></li><li data-type='method'><a href="Layer.html#propagate">propagate</a></li><li data-type='method'><a href="Layer.html#set">set</a></li></ul></li><li><a href="Neat.html">Neat</a><ul class='methods'><li data-type='method'><a href="Neat.html#createPool">createPool</a></li><li data-type='method'><a href="Neat.html#createPool">createPool</a></li><li data-type='method'><a href="Neat.html#evaluate">evaluate</a></li><li data-type='method'><a href="Neat.html#evaluate">evaluate</a></li><li data-type='method'><a href="Neat.html#evolve">evolve</a></li><li data-type='method'><a href="Neat.html#evolve">evolve</a></li><li data-type='method'><a href="Neat.html#export">export</a></li><li data-type='method'><a href="Neat.html#export">export</a></li><li data-type='method'><a href="Neat.html#getAverage">getAverage</a></li><li data-type='method'><a href="Neat.html#getAverage">getAverage</a></li><li data-type='method'><a href="Neat.html#getFittest">getFittest</a></li><li data-type='method'><a href="Neat.html#getFittest">getFittest</a></li><li data-type='method'><a href="Neat.html#getOffspring">getOffspring</a></li><li data-type='method'><a href="Neat.html#getOffspring">getOffspring</a></li><li data-type='method'><a href="Neat.html#getParent">getParent</a></li><li data-type='method'><a href="Neat.html#getParent">getParent</a></li><li data-type='method'><a href="Neat.html#import">import</a></li><li data-type='method'><a href="Neat.html#import">import</a></li><li data-type='method'><a href="Neat.html#mutate">mutate</a></li><li data-type='method'><a href="Neat.html#mutate">mutate</a></li><li data-type='method'><a href="Neat.html#selectMutationMethod">selectMutationMethod</a></li><li data-type='method'><a href="Neat.html#selectMutationMethod">selectMutationMethod</a></li><li data-type='method'><a href="Neat.html#sort">sort</a></li><li data-type='method'><a href="Neat.html#sort">sort</a></li></ul></li><li><a href="Network.html">Network</a><ul class='methods'><li data-type='method'><a href="Network.html#.crossOver">crossOver</a></li><li data-type='method'><a href="Network.html#.fromJSON">fromJSON</a></li><li data-type='method'><a href="Network.html#.merge">merge</a></li><li data-type='method'><a href="Network.html#activate">activate</a></li><li data-type='method'><a href="Network.html#clear">clear</a></li><li data-type='method'><a href="Network.html#connect">connect</a></li><li data-type='method'><a href="Network.html#disconnect">disconnect</a></li><li data-type='method'><a href="Network.html#evolve">evolve</a></li><li data-type='method'><a href="Network.html#gate">gate</a></li><li data-type='method'><a href="Network.html#graph">graph</a></li><li data-type='method'><a href="Network.html#mutate">mutate</a></li><li data-type='method'><a href="Network.html#noTraceActivate">noTraceActivate</a></li><li data-type='method'><a href="Network.html#propagate">propagate</a></li><li data-type='method'><a href="Network.html#remove">remove</a></li><li data-type='method'><a href="Network.html#serialize">serialize</a></li><li data-type='method'><a href="Network.html#set">set</a></li><li data-type='method'><a href="Network.html#standalone">standalone</a></li><li data-type='method'><a href="Network.html#test">test</a></li><li data-type='method'><a href="Network.html#toJSON">toJSON</a></li><li data-type='method'><a href="Network.html#train">train</a></li><li data-type='method'><a href="Network.html#ungate">ungate</a></li></ul></li><li><a href="Node.html">Node</a><ul class='methods'><li data-type='method'><a href="Node.html#.fromJSON">fromJSON</a></li><li data-type='method'><a href="Node.html#activate">activate</a></li><li data-type='method'><a href="Node.html#clear">clear</a></li><li data-type='method'><a href="Node.html#connect">connect</a></li><li data-type='method'><a href="Node.html#disconnect">disconnect</a></li><li data-type='method'><a href="Node.html#gate">gate</a></li><li data-type='method'><a href="Node.html#isProjectedBy">isProjectedBy</a></li><li data-type='method'><a href="Node.html#isProjectingTo">isProjectingTo</a></li><li data-type='method'><a href="Node.html#mutate">mutate</a></li><li data-type='method'><a href="Node.html#noTraceActivate">noTraceActivate</a></li><li data-type='method'><a href="Node.html#propagate">propagate</a></li><li data-type='method'><a href="Node.html#toJSON">toJSON</a></li><li data-type='method'><a href="Node.html#ungate">ungate</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="activation.html">activation</a><ul class='methods'><li data-type='method'><a href="activation.html#.ABSOLUTE">ABSOLUTE</a></li><li data-type='method'><a href="activation.html#.BENT_IDENTITY">BENT_IDENTITY</a></li><li data-type='method'><a href="activation.html#.BIPOLAR">BIPOLAR</a></li><li data-type='method'><a href="activation.html#.BIPOLAR_SIGMOID">BIPOLAR_SIGMOID</a></li><li data-type='method'><a href="activation.html#.GAUSSIAN">GAUSSIAN</a></li><li data-type='method'><a href="activation.html#.HARD_TANH">HARD_TANH</a></li><li data-type='method'><a href="activation.html#.IDENTITY">IDENTITY</a></li><li data-type='method'><a href="activation.html#.INVERSE">INVERSE</a></li><li data-type='method'><a href="activation.html#.LOGISTIC">LOGISTIC</a></li><li data-type='method'><a href="activation.html#.RELU">RELU</a></li><li data-type='method'><a href="activation.html#.SELU">SELU</a></li><li data-type='method'><a href="activation.html#.SINUSOID">SINUSOID</a></li><li data-type='method'><a href="activation.html#.SOFTSIGN">SOFTSIGN</a></li><li data-type='method'><a href="activation.html#.STEP">STEP</a></li><li data-type='method'><a href="activation.html#.TANH">TANH</a></li></ul></li><li><a href="architect.html">architect</a><ul class='methods'><li data-type='method'><a href="architect.html#.Construct">Construct</a></li><li data-type='method'><a href="architect.html#.GRU">GRU</a></li><li data-type='method'><a href="architect.html#.Hopfield">Hopfield</a></li><li data-type='method'><a href="architect.html#.Liquid">Liquid</a></li><li data-type='method'><a href="architect.html#.LSTM">LSTM</a></li><li data-type='method'><a href="architect.html#.NARX">NARX</a></li><li data-type='method'><a href="architect.html#.Perceptron">Perceptron</a></li><li data-type='method'><a href="architect.html#.Random">Random</a></li></ul></li><li><a href="connection_.html">connection</a><ul class='members'><li data-type='member'><a href="connection_.html#.ALL_TO_ALL">ALL_TO_ALL</a></li><li data-type='member'><a href="connection_.html#.ALL_TO_ELSE">ALL_TO_ELSE</a></li><li data-type='member'><a href="connection_.html#.ONE_TO_ONE">ONE_TO_ONE</a></li></ul></li><li><a href="cost.html">cost</a><ul class='methods'><li data-type='method'><a href="cost.html#.BINARY">BINARY</a></li><li data-type='method'><a href="cost.html#.CROSS_ENTROPY">CROSS_ENTROPY</a></li><li data-type='method'><a href="cost.html#.HINGE">HINGE</a></li><li data-type='method'><a href="cost.html#.MAE">MAE</a></li><li data-type='method'><a href="cost.html#.MAPE">MAPE</a></li><li data-type='method'><a href="cost.html#.MSE">MSE</a></li><li data-type='method'><a href="cost.html#.MSLE">MSLE</a></li><li data-type='method'><a href="cost.html#.WAPE">WAPE</a></li></ul></li><li><a href="crossover.html">crossover</a><ul class='members'><li data-type='member'><a href="crossover.html#.AVERAGE">AVERAGE</a></li><li data-type='member'><a href="crossover.html#.SINGLE_POINT">SINGLE_POINT</a></li><li data-type='member'><a href="crossover.html#.TWO_POINT">TWO_POINT</a></li><li data-type='member'><a href="crossover.html#.UNIFORM">UNIFORM</a></li></ul></li><li><a href="gating.html">gating</a><ul class='members'><li data-type='member'><a href="gating.html#.INPUT">INPUT</a></li><li data-type='member'><a href="gating.html#.OUTPUT">OUTPUT</a></li><li data-type='member'><a href="gating.html#.SELF">SELF</a></li></ul></li><li><a href="mutation.html">mutation</a><ul class='members'><li data-type='member'><a href="mutation.html#.ADD_BACK_CONN">ADD_BACK_CONN</a></li><li data-type='member'><a href="mutation.html#.ADD_CONN">ADD_CONN</a></li><li data-type='member'><a href="mutation.html#.ADD_GATE">ADD_GATE</a></li><li data-type='member'><a href="mutation.html#.ADD_NODE">ADD_NODE</a></li><li data-type='member'><a href="mutation.html#.ADD_SELF_CONN">ADD_SELF_CONN</a></li><li data-type='member'><a href="mutation.html#.ALL">ALL</a></li><li data-type='member'><a href="mutation.html#.FFW">FFW</a></li><li data-type='member'><a href="mutation.html#.MOD_ACTIVATION">MOD_ACTIVATION</a></li><li data-type='member'><a href="mutation.html#.MOD_BIAS">MOD_BIAS</a></li><li data-type='member'><a href="mutation.html#.MOD_WEIGHT">MOD_WEIGHT</a></li><li data-type='member'><a href="mutation.html#.SUB_BACK_CONN">SUB_BACK_CONN</a></li><li data-type='member'><a href="mutation.html#.SUB_CONN">SUB_CONN</a></li><li data-type='member'><a href="mutation.html#.SUB_GATE">SUB_GATE</a></li><li data-type='member'><a href="mutation.html#.SUB_NODE">SUB_NODE</a></li><li data-type='member'><a href="mutation.html#.SUB_SELF_CONN">SUB_SELF_CONN</a></li><li data-type='member'><a href="mutation.html#.SWAP_NODES">SWAP_NODES</a></li></ul></li><li><a href="rate.html">rate</a><ul class='methods'><li data-type='method'><a href="rate.html#.EXP">EXP</a></li><li data-type='method'><a href="rate.html#.FIXED">FIXED</a></li><li data-type='method'><a href="rate.html#.INV">INV</a></li><li data-type='method'><a href="rate.html#.STEP">STEP</a></li></ul></li><li><a href="selection.html">selection</a><ul class='members'><li data-type='member'><a href="selection.html#.FITNESS_PROPORTIONATE">FITNESS_PROPORTIONATE</a></li><li data-type='member'><a href="selection.html#.POWER">POWER</a></li><li data-type='member'><a href="selection.html#.TOURNAMENT">TOURNAMENT</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#config">config</a></li><li><a href="global.html#GAN">GAN</a></li></ul>
</nav>

<div id="main">
    <div class="columns">
        <div class="column is-hidden-touch"></div>
        <div class="column is-11-desktop is-10-widescreen">

            
                <h1 class="page-title">neat.js</h1>
            

            



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var Network = require('./architecture/network');
var methods = require('./methods/methods');
var config = require('./config');

// Easier variable naming
var selection = methods.selection;

/**
* Runs the NEAT algorithm on group of neural networks.
*
* @constructs Neat
*
* @param {number} input - The input size of the networks.
* @param {number} output - The output size of the networks
* @param {Array&lt;{input:number[],output:number[]}>} [dataset] A set of input values and ideal output values to evaluate a genome's fitness with. Must be included to use `NEAT.evaluate`
* @param {Object} options - Configuration options
* @param {boolean} [options.equal=false] When true [crossover](Network.crossOver) parent genomes are assumed to be equally fit and offspring are built with a random amount of neurons within the range of parents' number of neurons. Set to false to select the "fittest" parent as the neuron amount template.
* @param {number} [options.clear=false] Clear the context of the population's nodes, basically reverting them to 'new' neurons. Useful for predicting timeseries with LSTM's.
* @param {number} [options.popsize=50] Population size of each generation.
* @param {number} [options.elitism=1] Elitism of every evolution loop. [Elitism in genetic algortihtms.](https://www.researchgate.net/post/What_is_meant_by_the_term_Elitism_in_the_Genetic_Algorithm)
* @param {number} [options.provenance=0] Number of genomes inserted the original network template (Network(input,output)) per evolution.
* @param {number} [options.mutationRate=0] Sets the mutation rate. If set to 0.3, 30% of the new population will be mutated. Default is 0.3.
* @param {number} [options.mutationAmount=1] If mutation occurs (randomNumber &lt; mutationRate), sets amount of times a mutation method will be applied to the network.
* @param {boolean} [options.fitnessPopulation=false] Flag to return the fitness of a population of genomes. Set this to false to evaluate each genome inidividually.
* @param {Function} [options.fitness] - A fitness function to evaluate the networks. Takes a `genome`, i.e. a [network](Network), and a `dataset` and sets the genome's score property
* @param {string} [options.selection=FITNESS_PROPORTIONATE] [Selection method](selection) for evolution (e.g. Selection.FITNESS_PROPORTIONATE).
* @param {Array} [options.crossover] Sets allowed crossover methods for evolution.
* @param {Network} [options.network=false] Network to start evolution from
* @param {number} [options.maxNodes=Infinity] Maximum nodes for a potential network
* @param {number} [options.maxConns=Infinity] Maximum connections for a potential network
* @param {number} [options.maxGates=Infinity] Maximum gates for a potential network
* @param {function} [options.mutationSelection=ALL] Custom mutation selection function if given
* @param {mutation[]} [options.mutation] Sets allowed [mutation methods](mutation) for evolution, a random mutation method will be chosen from the array when mutation occurs. Optional, but default methods are non-recurrent
*
* @prop {number} generation A count of the generations
* @prop {Network[]} population The current population for the neat instance. Accessible through `neat.population`
*
* @example
* let { Neat } = require("@liquid-carrot/carrot");
*
* let neat = new Neat(4, 1, dataset, {
*   elitism: 10,
*   clear: true,
*   popsize: 1000
* });
*/
function Neat (input, output, dataset, options) {
  this.input = input; // The input size of the networks
  this.output = output; // The output size of the networks

  // Configure options
  options = options || {};
  this.equal = options.equal || true;
  this.clear = options.clear || false;
  this.popsize = options.popsize || 50;
  this.elitism = options.elitism || 1;
  this.provenance = options.provenance || 0;
  this.mutationRate = options.mutationRate || 0.4;
  this.mutationAmount = options.mutationAmount || 1;

  this.fitnessPopulation = options.fitnessPopulation || false;

  this.selection = options.selection || methods.selection.POWER;
  this.crossover = options.crossover || [
    methods.crossover.SINGLE_POINT,
    methods.crossover.TWO_POINT,
    methods.crossover.UNIFORM,
    methods.crossover.AVERAGE
  ];
  this.mutation = options.mutation || methods.mutation.FFW;
  this.efficientMutation = options.efficientMutation || false;

  this.template = options.network || (new Network(this.input, this.output));

  this.maxNodes = options.maxNodes || Infinity;
  this.maxConns = options.maxConns || Infinity;
  this.maxGates = options.maxGates || Infinity;

  // Custom mutation selection function if given
  this.selectMutationMethod = typeof options.mutationSelection === 'function' ? options.mutationSelection.bind(this) : this.selectMutationMethod;

  // Generation counter
  this.generation = 0;
  
  // Fitness function options
  fitnessFunction = function (genome, dataset) {
    let score = 0;
    
    for (var i = 0; i &lt; dataset.length; i++) {
      score -= genome[i].test(dataset).error;
    }
  
    score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * 0.0001;
    score = isNaN(score) ? -Infinity : score; // this can cause problems with fitness proportionate selection
  
    return score / amount;
  };
  this.fitness = options.fitness || fitnessFunction; // The fitness function to evaluate the networks

  // Initialise the genomes
  this.createPool(this.template);
}

/*
* @namespace NEAT
*/
Neat.prototype = {
  // A collection of utility functions to be used with Neat.
  util: {
    /*
     * Used to select and modify genomes as determined by the `pickGenome` function.
     *
     * @param {Network[]} population A population to filter
     * @param {Network} template A network template to replace picked genomes if `adjustGenome` is left unset.
     * @param {function} pickGenome A predicate function to mark genomes for adjustment. Accepts a network as a parameter and returns true for selection.
     * @param {function} adjustGenome Accepts a network, modifies it, and returns it. Used to modify unwanted genomes returned by `pickGenome` and reincorporate them into the population. If left unset, picked genomes will be replaced with the template Network.
     *
     * @returns {Network[]} A new filtered population
     */
    filterGenome: function(population, template, pickGenome, adjustGenome) {
      let filtered = [...population]; // avoid mutations
      const pick = function(genome) {
        const pick = pickGenome(genome)
        if (typeof pick !== "boolean") throw new Error("pickGenome must always return a boolean!")
        return pick
      }
      
      if(adjustGenome){
        for (let i = 0; i &lt; population.length; i++) {
          if(pick(filtered[i])) {
            const result = adjustGenome(filtered[i])
            if (!(result instanceof Network)) throw new Error("adjustGenome must always return a network!")
            filtered[i] = result
          }
        }
      } else
          for (let i = 0; i &lt; population.length; i++)
            if(pick(filtered[i])) filtered[i] = Network.fromJSON(template.toJSON)
    
      return filtered;
    },
  },
  
  /**
   * Create a pool of identical genomes.
   *
   * @param {Network} network An initial network to evolve from
   */
  createPool: function (network) {
    let self = this;
    self.population = [];

    for(let i = 0; i &lt; self.popsize; i++) {
      // POSSIBLE
      // self.population.push(Network.fromJSON({ ...network.toJSON(), score: undefined }))
      
      const copy = Network.fromJSON(network.toJSON());
      copy.score = undefined;
      self.population.push(copy);
    }
  },

  /**
   * Evaluates, selects, breeds and mutates population.
   *
   * @param {function} [pickGenome] A custom selection function to pick out unwanted genomes. Accepts a network as a parameter and returns true for selection.
   * @param {function} [adjustGenome=this.template] Accepts a network, modifies it, and returns it. Used to modify unwanted genomes returned by `pickGenome` and reincorporate them into the population. If left unset, unwanted genomes will be replaced with the template Network. Will only run when pickGenome is defined.
   * @returns {Network} Fittest network
   *
   * @example
   * let neat = new Neat(4, 1, dataset, {
   *  elitism: 10,
   *  clear: true,
   *  popsize: 1000
   * });
   *
   * let filter = function(genome) {
   *  // Remove genomes with more than 100 nodes
   *  return genome.nodes.length > 100 ? true : false
   * }
   *
   * let adjust = function(genome) {
   *  // clear the nodes
   *  return genome.clear()
   * }
   *
   * neat.evolve(filter, adjust).then(function(fittest) {
   *  console.log(fittest)
   * })
  */
  evolve: async function (pickGenome, adjustGenome) {
    if(this.elitism + this.provenance > this.popsize) throw new Error("Can't evolve! Elitism + provenance exceeds population size!");
    
    // Assign fitness score(s) to the population if needed
    if (typeof this.population[this.population.length - 1].score === 'undefined') await this.evaluate()
    
    // Check &amp; adjust genomes as needed
    if(pickGenome) this.population = this.util.filterGenome(this.population, this.template, pickGenome, adjustGenome)
    
    // Sort in order of fitness (fittest first)
    this.sort();
    var fittest = Network.fromJSON(this.population[0].toJSON());
    fittest.score = this.population[0].score;

    var newPopulation = [];

    // Elitism
    var elitists = [];
    for (var i = 0; i &lt; this.elitism; i++) {
      elitists.push(this.population[i]);
    }

    // Provenance
    for (i = 0; i &lt; this.provenance; i++) {
      newPopulation.push(Network.fromJSON(this.template.toJSON()));
    }
    
    // Breed the next individuals
    for (i = 0; i &lt; this.popsize - this.elitism - this.provenance; i++) {
      newPopulation.push(this.getOffspring());
    }

    // Replace the old population with the new population
    this.population = newPopulation;
    this.mutate();

    this.population.push(...elitists);
    
    if(pickGenome) this.population = this.util.filterGenome(this.population, this.template, pickGenome, adjustGenome)

    // Reset the scores
    for (i = 0; i &lt; this.population.length; i++) {
      this.population[i].score = undefined;
    }

    this.generation++;

    return fittest;
  },

  /**
   * Selects two genomes from the population with `getParent()`, and returns the offspring from those parents. NOTE: Population MUST be sorted
   *
   * @returns {Network} Child network
   */
  getOffspring: function () {
    var parent1 = this.getParent();
    var parent2 = this.getParent();

    return Network.crossOver(parent1, parent2, this.equal);
  },

  /**
   * Selects a random mutation method for a genome according to the parameters
   * @param {Network} genome
  */
  selectMutationMethod: function (genome) {
    let mutation = this.mutation;

    let mutationMethod = mutation[Math.floor(Math.random() * mutation.length)];

    if (mutationMethod === methods.mutation.ADD_NODE &amp;&amp; genome.nodes.length >= this.maxNodes) {
      if (config.warnings) console.warn('maxNodes exceeded!');
      return null;
    }

    if (mutationMethod === methods.mutation.ADD_CONN &amp;&amp; genome.connections.length >= this.maxConns) {
      if (config.warnings) console.warn('maxConns exceeded!');
      return null;
    }

    if (mutationMethod === methods.mutation.ADD_GATE &amp;&amp; genome.gates.length >= this.maxGates) {
      if (config.warnings) console.warn('maxGates exceeded!');
      return null;
    }

    return mutationMethod;
  },

  /**
   * Mutates the given (or current) population
   */
  mutate: function () {
    // Elitist genomes should not be included
    for (var i = 0; i &lt; this.population.length; i++) {
      if (Math.random() &lt;= this.mutationRate)
        for (var j = 0; j &lt; this.mutationAmount; j++)
          this.population[i].mutate(this.selectMutationMethod(this.population[i]));
    }
  },

  /**
   * Sets fitness scores for the current population members.
   */
  evaluate: async function () {
    if(!this.dataset) {
      throw new Error("You must include a dataset to use NEAT.evaluate()")
    }
    var i;
    if (this.fitnessPopulation) {
      if (this.clear) {
        for (i = 0; i &lt; this.population.length; i++) {
          this.population[i].clear();
        }
      }
      await this.fitness(this.population, this.dataset);
    } else {
      for (i = 0; i &lt; this.population.length; i++) {
        var genome = this.population[i];
        if (this.clear) genome.clear();
        genome.score = await this.fitness(genome, this.dataset);
      }
    }
  },

  /**
   * Sorts the population by fitness
   */
  sort: function () {
    this.population.sort(function (a, b) {
      return b.score - a.score;
    });
  },

  /**
   * Returns the fittest genome of the current population
   *
   * @returns {Network} Current population's fittest genome
  */
  getFittest: function () {
    // Check if evaluated
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      this.evaluate();
    }
    if (this.population[0].score &lt; this.population[1].score) {
      this.sort();
    }

    return this.population[0];
  },

  /**
   * Returns the average fitness of the current population
   *
   * @returns {number} Average fitness of the current population
   */
  getAverage: function () {
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      this.evaluate();
    }

    var score = 0;
    for (var i = 0; i &lt; this.population.length; i++) {
      score += this.population[i].score;
    }

    return score / this.population.length;
  },

  /**
   * Returns a genome for recombination (crossover) based on one of the [selection methods](selection) provided.
   *
   * Should be called after `evaluate()`
   *
   * @return {Network} Selected genome for offspring generation
   */
  getParent: function () {
    var i;
    switch (this.selection) {
      case selection.POWER:
        if (this.population[0].score &lt; this.population[1].score) this.sort(); // SHOULD FIX: Not guaranteed to detect an unsorted population

        var index = Math.floor(Math.pow(Math.random(), this.selection.power) * this.population.length);
        return this.population[index];
      case selection.FITNESS_PROPORTIONATE:
        // As negative fitnesses are possible
        // https://stackoverflow.com/questions/16186686/genetic-algorithm-handling-negative-fitness-values
        // this is unnecessarily run for every individual, should be changed

        var totalFitness = 0;
        var minimalFitness = 0;
        for (i = 0; i &lt; this.population.length; i++) {
          var score = this.population[i].score;
          minimalFitness = score &lt; minimalFitness ? score : minimalFitness;
          totalFitness += score;
        }

        minimalFitness = Math.abs(minimalFitness);
        totalFitness += minimalFitness * this.population.length;

        var random = Math.random() * totalFitness;
        var value = 0;

        for (i = 0; i &lt; this.population.length; i++) {
          let genome = this.population[i];
          value += genome.score + minimalFitness;
          if (random &lt; value) return genome;
        }

        // if all scores equal, return random genome
        return this.population[Math.floor(Math.random() * this.population.length)];
      case selection.TOURNAMENT:
        if (this.selection.size > this.popsize) {
          throw new Error('Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size');
        }

        // Create a tournament
        var individuals = [];
        for (i = 0; i &lt; this.selection.size; i++) {
          let random = this.population[Math.floor(Math.random() * this.population.length)];
          individuals.push(random);
        }

        // Sort the tournament individuals by score
        individuals.sort(function (a, b) {
          return b.score - a.score;
        });

        // Select an individual
        for (i = 0; i &lt; this.selection.size; i++) {
          if (Math.random() &lt; this.selection.probability || i === this.selection.size - 1) {
            return individuals[i];
          }
        }
    }
  },

  /**
   * Export the current population to a JSON object
   *
   * Can be used later with `import(json)` to reload the population
   *
   * @return {object[]} A set of genomes (a population) represented as JSON objects.
   */
  export: function () {
    var json = [];
    for (var i = 0; i &lt; this.population.length; i++) {
      var genome = this.population[i];
      json.push(genome.toJSON());
    }

    return json;
  },

  /**
   * Imports population from a json. Must be an array of networks converted to JSON objects.
   *
   * @param {object[]} json set of genomes (a population) represented as JSON objects.
  */
  import: function (json) {
    var population = [];
    for (var i = 0; i &lt; json.length; i++) {
      var genome = json[i];
      population.push(Network.fromJSON(genome));
    }
    this.population = population;
    this.popsize = population.length;
  }
};

module.exports = Neat;
</code></pre>
        </article>
    </section>





            

        </div>
        <div class="column is-hidden-touch"></div>
    </div>
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.1</a> on Thu May 23 2019 02:34:31 GMT-0400 (Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/jquery-3.1.1.min.js"></script>

<script src="scripts/search.js"></script>




<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","resetIdentity","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
  heap.load("1195922815");
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {

  // Get all "navbar-burger" elements
  const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

  // Check if there are any navbar burgers
  if ($navbarBurgers.length > 0) {

    // Add a click event on each of them
    $navbarBurgers.forEach( el => {
      el.addEventListener('click', () => {

        // Get the target from the "data-target" attribute
        const target = el.dataset.target;
        const $target = document.getElementById(target);

        // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
        el.classList.toggle('is-active');
        $target.classList.toggle('is-active');

      });
    });
  }

});
</script>
</body>
</html>
